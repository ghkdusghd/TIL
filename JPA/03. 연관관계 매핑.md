# 연관관계 매핑

> 객체와 테이블 연관관계의 차이를 생각해보자. 자바에서는 연관관계를 갖는 객체의 경우 '참조'하는 방식으로 값을 가져오지만 DB 테이블은 외래 키로 제약 조건을 설정하여 참조 무결성을 지킨다. 다시 말해 연관관계를 갖는 객체(테이블)의 값을 가져오는 방식이 다른 것이다.

### 🧩 연관관계가 필요한 이유

- 앞서 살펴본 방법대로, 객체를 테이블에 맞춰 모델링한다고 생각해보자.

- 테이블은 외래 키 설정으로 연관관계를 맺었지만 이를 그대로 자바 객체로 옮기면 객체 간의 연관관계를 설정하기 어려워진다.

<img src="images/02. Member, Team table.png">
<span style="color: #808080">출처: 자바 ORM 표준 JPA 프로그래밍 - 기본편 (인프런)</span>

&nbsp;

🍥 엔티티 매핑

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    @Column(name = "USERNAME")
    private String name;

    @Column(name = "TEAM_ID")
    private Long teamId;
}

@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;
    private String name;
}
```

&nbsp;

🍥 CRUD

- 이렇게 매핑한 이후 CRUD 작업에 들어갔을 때 아래와 같은 방식으로 작업을 하게 되는데,

- 연관관계에 있는 객체를 직접 참조하지 못하고, id 라는 식별자로 조회해야 한다. (객체지향적인 방법이 아니다...)

```java
// TeamA 생성
Team team = new Team();
team.setName("TeamA");
em.persist(team);

// TeamA에 멤버 저장
Member member = new Member();
member.setName("memberA");
member.setTeamId(team.getId());
em.persist(member);

// 저장한 팀과 그 팀의 멤버를 조회
Member findMember = em.find(Member.class, member.getId());
Team findTeam = em.find(Team.class, team.getId());
```

- 결론적으로, 객체를 테이블에 맞추어 데이터 중심으로 모델링하면 협력 관계를 만들 수 없다.

### 🧩 단방향 연관관계

> 단방향 연관관계 설명...

- Team, Member 테이블을 객체 지향적으로 다시 설계해보자.

-

```java
public class Member {

    @Id @GeneratedValue
    private Long id;

    @Column(name = "USERNAME")
    private String name;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
}
```
